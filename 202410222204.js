/*
Fibonacci 數列的時間複雜度

    遞歸算法：
        時間複雜度：O(2^n)
        解釋：因為每次計算 Fibonacci(n) 會分別計算 Fibonacci(n-1) 和 Fibonacci(n-2)，
		這樣會造成大量重複計算，導致時間複雜度呈指數增長。

    for算法：
        時間複雜度：O(n)
        解釋：透過迭代，可以一次性計算到第 n 項，避免重複計算。每次只需要常數時間來更新前兩項的值。

    動態規劃：
        時間複雜度：O(n)
        空間複雜度：O(n)（若使用數組存儲所有計算結果）或 O(1)（若只記錄最後兩項）。
        解釋：這種方法記錄已計算的值，避免重複計算，並可以有效地計算出第 n 項。

實際應用

    自然界：Fibonacci 數列經常出現在自然界中，例如植物的生長模式（如向日葵的種子排列、松果的螺旋形排列），
	這種排列可以最有效地利用空間。

    金融市場：在技術分析中，Fibonacci 數列用於預測股票價格的回調和反轉點，
	投資者利用 Fibonacci 反向和延伸水平進行交易決策。

    計算機科學：Fibonacci 數列在數據結構和演算法中有多種應用，例如在某些排序和搜索算法中，
	或用於設計高效的樹結構（如 Fibonacci 堆）。

    藝術和建築：Fibonacci 數列和黃金比例密切相關，常用於設計和構圖，以達到美學上的平衡。

*/

//1. 遞歸實現

function fibRecursive(n) {
    if (n <= 1) return n;
    return fibRecursive(n - 1) + fibRecursive(n - 2);
}

//時間複雜度：O(2^n)
//空間複雜度：O(n)（由於遞歸調用棧）

//2. for實現
function fibIterative(n) {
    if (n <= 1) return n;
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

//時間複雜度：O(n)
//空間複雜度：O(1)（只使用常數空間）

//3. 動態規劃實現

function fibDynamic(n) {
    if (n <= 1) return n;
    let dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

//時間複雜度：O(n)
//空間複雜度：O(n)（需要存儲所有計算結果）

/*

記憶體使用

在 JavaScript 中，記憶體的使用量難以精確測量，通常需要使用專門的工具或瀏覽器的開發者工具來分析。一般來說：

    遞歸：由於每次遞歸都會在調用棧上增加新層，記憶體使用會隨著 n 增加而顯著增加。
    迭代：由於只使用常數變量，記憶體使用保持在 O(1)。
    動態規劃：由於需要額外的數組來存儲計算結果，記憶體使用量為 O(n)。

*/